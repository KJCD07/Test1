
SET @Command = 
    'XCOPY "' + @SourceFolder + '" "' + @DestinationFolder + '" /D /Y';



SET @cmd = 
    'forfiles /P "c:\backup" /D +0 /C "cmd /c copy @path c:\shared"';





-- Step 1: Create a temporary table to store file names
CREATE TABLE #FileList (
    FileName NVARCHAR(255)
);

-- Step 2: Use xp_cmdshell to list files modified today
DECLARE @cmd NVARCHAR(MAX);
DECLARE @FolderPath NVARCHAR(255) = 'C:\backup'; -- Change this to your folder path

-- Command to list files modified today using forfiles
SET @cmd = 'forfiles /P "' + @FolderPath + '" /D +0 /C "cmd /c echo @file"';

-- Insert the output of the command into the temporary table
INSERT INTO #FileList (FileName)
EXEC xp_cmdshell @cmd;

-- Step 3: Clean up null and irrelevant rows from the temporary table
DELETE FROM #FileList WHERE FileName IS NULL OR FileName LIKE '%.';

-- Step 4: View the filenames in the temporary table
SELECT * FROM #FileList;

-- Optional: Drop the temporary table after use
-- DROP TABLE #FileList;








*****************************************************************************************************************


-- Step 1: Create a staging table for raw data
CREATE TABLE StagingTable (
    RawLine NVARCHAR(MAX) -- Holds each line as raw text
);

-- Step 2: Bulk insert raw data into the staging table
BULK INSERT StagingTable
FROM 'C:\Path\To\Your\File.txt'
WITH (
    FIELDTERMINATOR = '\n', -- Rows are separated by newline
    ROWTERMINATOR = '\n',
    TABLOCK -- Speeds up bulk insert by locking the table
);

-- Step 3: Create the target table with 23 columns
CREATE TABLE TargetTable (
    Col1 NVARCHAR(255) NOT NULL,
    Col2 NVARCHAR(255) NOT NULL,
    Col3 NVARCHAR(255) NOT NULL,
    -- Add placeholders for the remaining columns
    Col4 NVARCHAR(255) NULL,
    -- Continue up to Col23
    Col23 NVARCHAR(255) NULL
);

-- Step 4: Extract first three values from the raw data and insert into the target table
WITH ParsedData AS (
    SELECT
        -- Extract first delimiter-separated value
        LEFT(RawLine, CHARINDEX('|', RawLine + '|') - 1) AS Col1,
        -- Extract second value
        SUBSTRING(RawLine, CHARINDEX('|', RawLine + '|') + 1,
                  CHARINDEX('|', RawLine + '|', CHARINDEX('|', RawLine + '|') + 1)
                  - CHARINDEX('|', RawLine + '|') - 1) AS Col2,
        -- Extract third value
        SUBSTRING(RawLine, CHARINDEX('|', RawLine + '|', CHARINDEX('|', RawLine + '|') + 1) + 1,
                  CHARINDEX('|', RawLine + '|', CHARINDEX('|', RawLine + '|', CHARINDEX('|', RawLine + '|') + 1) + 1)
                  - CHARINDEX('|', RawLine + '|', CHARINDEX('|', RawLine + '|') + 1) - 1) AS Col3
    FROM StagingTable
)
INSERT INTO TargetTable (Col1, Col2, Col3)
SELECT Col1, Col2, Col3
FROM ParsedData;

-- Step 5: Drop the staging table to free resources
DROP TABLE StagingTable;


***********************************************************************************************
-- Insert the first three values into TargetTable
INSERT INTO TargetTable (Col1, Col2, Col3)
SELECT 
    -- Extract the first value before the first "|"
    LEFT(RawData, CHARINDEX('|', RawData + '|') - 1) AS Col1,

    -- Extract the second value between the first and second "|"
    CASE 
        WHEN CHARINDEX('|', RawData + '|') > 0 THEN 
            SUBSTRING(RawData, CHARINDEX('|', RawData + '|') + 1,
                      CHARINDEX('|', RawData + '|', CHARINDEX('|', RawData + '|') + 1) - CHARINDEX('|', RawData + '|') - 1)
        ELSE NULL
    END AS Col2,

    -- Extract the third value between the second and third "|"
    CASE 
        WHEN CHARINDEX('|', RawData + '|', CHARINDEX('|', RawData + '|') + 1) > 0 THEN
            SUBSTRING(RawData, CHARINDEX('|', RawData + '|', CHARINDEX('|', RawData + '|') + 1) + 1,
                      CHARINDEX('|', RawData + '|', CHARINDEX('|', RawData + '|', CHARINDEX('|', RawData + '|') + 1) + 1) 
                      - CHARINDEX('|', RawData + '|', CHARINDEX('|', RawData + '|') + 1) - 1)
        ELSE NULL
    END AS Col3
FROM SourceTable;











*******************************************************************

-- Insert first 3 values into TargetTable
INSERT INTO TargetTable (Col1, Col2, Col3)
SELECT 
    MAX(CASE WHEN RowNum = 1 THEN Value END) AS Col1,
    MAX(CASE WHEN RowNum = 2 THEN Value END) AS Col2,
    MAX(CASE WHEN RowNum = 3 THEN Value END) AS Col3
FROM (
    SELECT 
        t.RawData,
        s.value AS Value,
        ROW_NUMBER() OVER (PARTITION BY t.RawData ORDER BY (SELECT NULL)) AS RowNum
    FROM SourceTable t
    CROSS APPLY STRING_SPLIT(t.RawData, '|') s
) ExtractedData
GROUP BY RawData;



*************************************************



DECLARE @FolderPath NVARCHAR(255) = 'C:\YourFolderPath'
DECLARE @Command NVARCHAR(4000)
DECLARE @Result INT

-- Build command to check folder existence
SET @Command = 'IF EXIST "' + @FolderPath + '" (EXIT 0) ELSE (EXIT 1)'

-- Run the command and capture the result
EXEC @Result = xp_cmdshell @Command, NO_OUTPUT

-- Check if folder exists
IF @Result = 0
    PRINT 'Folder exists'
ELSE
    PRINT 'Folder does not exist'




**********************************************************************



SELECT 
    ip.ARNG_ID AS ArngId,
    a.ARNG_NO AS AccountNumber,
    a.ARNG_TYP_CD AS ProductCode,
    a.AccountName AS AccountName,
    RTRIM(
        COALESCE(p.FRST_NM, '') + ' ' + 
        COALESCE(p.MID_NM, '') + ' ' + 
        COALESCE(p.LST_NM, '') + ' ' + 
        COALESCE(p.BUS_NM, '')
    ) AS CustomerName,
    a.ARNG_CO_CD AS CompanyNumber,
    p.PTY_ID AS PartyId,
    p.GCI_NO AS GCI,
    a.NOTIC_DT AS NoticeDate,
    a.RSTRC_DT AS RecommendedRestrictionDate,
    a.SCHD_CLS_DT AS ScheduledClosureDate,
    p.TAX_ID AS TaxId,
    a.CLS_RSN_TX AS ClosureReason
FROM ARNG_IP ip
JOIN CSTS p 
    ON ip.PTY_ID = p.PTY_ID
JOIN ARNGS a 
    ON ip.ARNG_ID = a.ARNG_ID
WHERE 
    ip.DEL_FL = 0 
    AND p.DEL_FL = 0
    AND a.DEL_FL = 0
    AND ip.ARNG_STAT_ID IN (<PendingClosureStatus>, <ChargeOffStatus>) 
    AND a.ACC_CLS_TEAM_PRCS_CLS_DT IS NOT NULL
    AND a.ACC_CLS_DT IS NOT NULL
    AND a.ARNG_TYP_CD = <ProductCode>
    AND ip.PRMRY_ARNG_IP_FL = 1
    AND ip.PRMRY_CAS_FL = 1
    AND ip.CAS_DOM_ID = <DomainId>
    AND NOT EXISTS (
        SELECT 1 
        FROM ProductQueueAction x
        WHERE x.ArngId = a.ARNG_ID
        AND x.Action IN (
            <AccountClosureInProgress>,
            <AssistanceRequired>,
            <LetterMailRequested>,
            <AccountRestrictionRequested>
        )
        AND x.IsDeleted = 0
    )
    AND EXISTS (
        SELECT 1 
        FROM subcodes x 
        WHERE x.lob_grp = 'SMALL BUSINESS' 
        AND x.ARNG_ID = a.ARNG_ID
    )
    AND a.NOTIC_DT IS NOT NULL;


******************************************

SELECT 
    ip.ARNG_ID AS ArngId,
    a.ARNG_NO AS AccountNumber,
    a.ARNG_TYP_CD AS ProductCode,
    a.AccountName AS AccountName,
    CONCAT(p.FIRST_NM, ' ', p.LAST_NM) AS CustomerName,
    a.ARNG_CO_CD AS CompanyNumber,
    p.PTY_ID AS PartyId,
    p.GCI AS GCI,
    a.NOTC_DT AS NoticeDate,
    a.RSTRC_DT AS RecommendedRestrictionDate,
    a.SCHD_CLS_DT AS ScheduledClosureDate,
    p.TAX_ID AS TaxId,
    cls.RSN_TX AS ClosureReason
FROM ARNG_TLP ip
JOIN CSTS p ON ip.PTY_ID = p.PTY_ID
JOIN ARNGS a ON ip.ARNG_ID = a.ARNG_ID
WHERE ip.DELFL IS NOT NULL AND ip.DELFL = 1
AND a.ARNG_STAT_ID = CAST(@ChargeOff AS INT)
AND acc.CLS_ID IS NOT NULL AND acc.CLS_ID = 1
AND EXISTS (
    SELECT 1 
    FROM ProductQueueAction pq 
    WHERE pq.ARNG_ID = a.ARNG_ID
)
AND ip.PRRY_ARNG_TPL = 1
AND ip.CAS_DOM_ID = @domainId 
AND ip.PRRY_CAS_FL = 1
AND a.ARNG_TYP_CD IN (@productCodeList)
AND cls.RSN_TX IN (@clsqryList);









